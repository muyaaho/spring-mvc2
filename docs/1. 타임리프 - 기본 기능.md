## 프로젝트 생성

- Dependencies: Spring Web, Lombok, Thymeleaf

<br><br>

## 롬복 적용

- Preferences Annotation Processors 검색 Enable annotation processing 체크 (재시작)

<br><br>

## 타임리프 소개

- 공식 사이트: https://www.thymeleaf.org/
- 공식 매뉴얼 - 기본 기능: https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html
- 공식 매뉴얼 - 스프링 통합: https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html

<br>

### 타임리프 특징

- 서버 사이드 HTML 랜더링 (SSR)
    - 백엔드 서버에서 HTML을 동적으로 랜더링 하는 용도로 사용된다.
- 네추럴 템플릿
    - 타임리프는 순수 HTML을 최대한 유지하는 특성이 있다.
        - 웹 브라우저에서 파일을 직접 열어도 내용을 확인할 수 있고, 서버를 통해 뷰 템플릿을 거치면 동적으로 변경된 결과를 확인할 수 있다.
        - JSP는 파일 자체를 열었을 때 JSP 소스코드와 HTML이 뒤죽박죽 섞여 웹 브라우저에서 정상적인 HTML 결과를 확인할 수 없다. 오직 서버를 통해 JSP가 랜더링이 되고 HTML 응답 결과를 받아야 화면을 확인할 수 있다.
        - 타임리프는 해당 파일을 웹 브라우저에서 열었을 때 정상적인 HTML 결과를 확인할 수 있다. 동적으로 결과가 랜더링 되진 않지만, HTML 마크업 결과가 어떻게 되는지 파일만 열어도 바로 확인할 수 있다.
    - 이렇게 **순수 HTML을 그대로 유지하면서 뷰 템플릿도 사용할 수 있는 타임리프의 특징을 네추럴 템플릿(natural templates)**이라 한다.
- 스프링 통합 지원
    - 타임리프는 스프링과 자연스럽게 통합되고 스프링의 다양한 기능을 편리하게 사용할 수 있게 지원한다.

<br><br>

## 타임리프 기본 기능

### 타임리프 사용 선언

```html
<html xmlns:th="http://www.thymeleaf.org">
```

<br>

### 기본 표현식

```
• 간단한 표현:
  ◦ 변수 표현식: ${...}
  ◦ 선택 변수 표현식: *{...}
  ◦ 메시지 표현식: #{...}
  ◦ 링크 URL 표현식: @{...}
  ◦ 조각 표현식: ~{...}
• 리터럴
  ◦ 텍스트: 'one text', 'Another one!',…
  ◦ 숫자: 0, 34, 3.0, 12.3,…
  ◦ 불린: true, false
  ◦ 널: null
  ◦ 리터럴 토큰: one, sometext, main,…
• 문자 연산:
  ◦ 문자 합치기: +
  ◦ 리터럴 대체: |The name is ${name}|
• 산술 연산:
  ◦ Binary operators: +, -, *, /, %
  ◦ Minus sign (unary operator): -
• 불린 연산:
  ◦ Binary operators: and, or
  ◦ Boolean negation (unary operator): !, not
• 비교와 동등:
  ◦ 비교: >, <, >=, <= (gt, lt, ge, le)
  ◦ 동등 연산: ==, != (eq, ne)
• 조건 연산:
  ◦ If-then: (if) ? (then)
  ◦ If-then-else: (if) ? (then) : (else)
  ◦ Default: (value) ?: (defaultvalue)
• 특별한 토큰:
  ◦ No-Operation: _
```

<br>

### 텍스트 - text, utext

- 타임리프의 가장 기본 기능은 텍스트를 출력하는 기능을 먼저 알아보자.
- 타임리프는 기본적으로 HTML 태그의 속성에 기능을 정의해서 동작한다. HTML의 컨텐츠에 데이터를 출력할 땐 다음과 같이 `th:text`를 사용하면 된다.
    - `<span th:text="${data}">`
- HTML 태그의 속성이 아니라 HTML 컨텐츠 영역 안에서 직접 데이터를 출력하고 싶으면 다음과 같이 `[[...]]`를 사용하면 된다.
    - 컨텐츠 안에서 직접 출력하기: `[[${data}]]`

```java
// BasicController

@Controller
@RequestMapping("/basic")
public class BasicController {

    @GetMapping("text-basic")
    public String textBasic(Model model) {
        model.addAttribute("data", "Hello Spring!");
        return "basic/text-basic";
    }
}
```

```html
<body>
    <h1>컨텐츠에 데이터 출력하기</h1>
    <ul>
        <li>th:text 사용 <span th:text="${data}"></span></li>
        <li>컨텐츠 안에서 직접 출력하기 = [[${data}]]</li>
    </ul>
</body>
```

<img src=https://github.com/muyaaho/spring-mvc2/assets/76798969/fc422df7-78d8-4035-b2cc-6655a1398afa width="60%" height="60%"/><br>

<br><br>

## Escape

- HTML 문서는 `<`, `>`같은 특수 문자를 기반으로 정의된다. 따라서 뷰 템플릿으로 HTML 화면을 생성할 때는 출력하는 데이터에 이러한 특수 문자가 있는 것을 주의해서 사용해야 한다.

<br>

#### 변경 전

`"Hello Spring!"`

<br>

#### 변경 후

`"Hello <b>Spring!</b>`

`<b>` 태그를 사용해서 **Spring!**이라는 단어가 진하게 나오도록 해보자.

- 웹 브라우저에서 실행 결과를 보자
    - 웹 브라우저: `Hello <b>Spring!</b>`
    - 소스 보기: `Hello &lt;b&gt;Spring!&lt;/b&gt;`
- 개발자가 의도한 것은 `<b>`가 있으면 해당 부분을 강조하는 것이 목적이었는데 `<b>` 태그가 그대로 나온다.
- 소스보기를 하면 `<` 부분이 `&lt;` 로 변경된 것을 확인할 수 있다.

<br>

### HTML 엔티티

- 웹 브라우저는 `<`를 HTML 태그의 시작으로 인식한다. 따라서 `<`를 태그의 시작이 아니라 문자로 표현할 방법이 필요한데, 이것을 **HTML 엔티티**라 한다.
- 그리고 HTML에서 사용하는 특수 문자를 HTML 엔티티로 변경하는 것을 이스케이프(escape)라 한다.
- 타임리프가 제공하는 `th:text`, `[[...]]`는 **기본적으로 이스케이프(escape)를 제공**한다.
    - `<` → `&lt;`
    - `>` → `&gt;`
    - 더 자세한 내용은 HTML 엔티티로 검색해 보자.

<br><br>

## Unescape

- 타임리프는 이스케이프를 사용하지 않는 기능을 제공한다.
    - `th:text` → `th:utext`
    - `[[...]]` → `[(...)]`

<br>

```java
// BasicController
    @GetMapping("text-unescaped")
    public String textUnescaped(Model model) {
        model.addAttribute("data", "Hello <b>Spring!</b>");
        return "basic/text-unescaped";
    }
```

```html
<body>
<h1>text vs utext</h1>
<ul>
    <li>th:text = <span th:text="${data}"></span></li>
    <li>th:utext = <span th:utext="${data}"></span></li>
</ul>
<h1><span th:inline="none">[[...]] vs [(...)]</span></h1>
<ul>
    <li><span th:inline="none">[[...]] = </span>[[${data}]]</li>
    <li><span th:inline="none">[(...)] = </span>[(${data})]</li>
</ul>
</body>
```

<img src=https://github.com/muyaaho/spring-mvc2/assets/76798969/84231eba-d3a8-4aa6-9e0b-0c04e5a057cc width="60%" height="60%"/><br>

- `th:inline="none"` : 타임리프는 `[[...]]` 를 해석하기 때문에 화면에 `[[...]]` 글자를 보여줄 수 없다. 이 태그 안에서는 타임리프가 해석하지 말라는 옵션이다.

> **주의!**  
실제 서비스를 개발하다 보면 escape를 사용하지 않아서 HTML이 정상 렌더링 되지 않는 수많은 문제가 발생한다. 
escape를 기본으로 하고, 꼭 필요할 때만 unescape를 사용하자.
> 

<br><br>

## 변수 - SpringEL

타임리프에서 변수를 사용할 때는 변수 표현식을 사용한다.

### 변수 표현식

- `${...}`
- 이 변수 표현식에는 스프링 EL이라는 스프링이 제공하는 표현식을 사용할 수 있다.

<br>

```java
// BasicController
    @GetMapping("/variable")
    public String variable(Model model) {
        User userA = new User("userA", 10);
        User userB = new User("userB", 20);

        List<User> list = new ArrayList<>();
        list.add(userA);
        list.add(userB);

        Map<String, User> map = new HashMap<>();
        map.put("userA", userA);
        map.put("userB", userB);

        model.addAttribute("user", userA);
        model.addAttribute("users", list);
        model.addAttribute("userMap", map);

        return "basic/variable";
    }
    
    @Data
    static class User {
        private String username;
        private int age;

        public User(String username, int age) {
            this.username = username;
            this.age = age;
        }
    }
```

```html
<body>
<h1>SpringEL 표현식</h1>
<ul>Object
    <li>${user.username} = <span th:text="${user.username}"></span></li>
    <li>${user['username']} = <span th:text="${user['username']}"></span></li>
    <li>${user.getUsername()} = <span th:text="${user.getUsername()}"></span></li>
</ul>
<ul>List
    <li>${users[0].username} = <span th:text="${users[0].username}"></span></li>
    <li>${users[0]['username']} = <span th:text="${users[0]['username']}"></span></li>
    <li>${users[0].getUsername()} = <span th:text="${users[0].getUsername()}"></span></li>
</ul>
<ul>Map
    <li>${userMap['userA'].username} = <span th:text="${userMap['userA'].username}"></span></li>
    <li>${userMap['userA']['username']} = <span th:text="${userMap['userA']['username']}"></span></li>
    <li>${userMap['userA'].getUsername()} = <span th:text="${userMap['userA'].getUsername()}"></span></li>
</ul>

<h1>지역 변수 - (th:with)</h1>
<div th:with="first=${users[0]}">
    <p>처음 사람의 이름은 <span th:text="${first.username}"></span></p>
</div>
</body>
```

<br>

### SpringEL 다양한 표현식 사용

#### Object

- `user.username`: user의 username을 프로퍼티 접근 → `user.getUsername()`
- `user['username']` : 동적으로 값을 꺼낼 수 있다. → `user.getUsername()`
- `user.getUsername()`: user의 `getUsername()`을 직접 호출한다.

#### List

- `users[0].username`: List에서 첫 번째 회원을 찾고 username 프로퍼티 접근 → `list.get(0).getUsername()`
- `user[0]['username']`: 위와 같다.
- `users[0].getUsername()`: List에서 첫 번째 회원을 찾고 메서드 직접 호출

#### Map

- `userMap['userA'].username`: Map에서 userA를 찾고 username 프로퍼티 접근 → `map.get("userA").getUsername()`
- `userMap[’userA’][’username’]`: 위와 같음
- `userMap['userA'].getUsername()`: Map에서 userA를 찾고 메서드 직접 호출
